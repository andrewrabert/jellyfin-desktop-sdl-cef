# Jellyfin Media Player - macOS bundle completion script
# Configured by CMake, run during install to fix library paths

set(app "${CMAKE_INSTALL_PREFIX}/@APP_NAME@")
set(macos_dir "${app}/Contents/MacOS")
set(frameworks_dir "${app}/Contents/Frameworks")

# Detect homebrew prefix
execute_process(
  COMMAND brew --prefix
  OUTPUT_VARIABLE brew_prefix
  OUTPUT_STRIP_TRAILING_WHITESPACE
)
set(brew_lib "${brew_prefix}/lib")

message(STATUS "Homebrew prefix: ${brew_prefix}")
message(STATUS "App bundle: ${app}")

#
# Fix CEF framework paths for bundle structure
# Build sets @executable_path/Frameworks/... but bundle needs @executable_path/../Frameworks/...
#
set(CEF_FRAMEWORK_NAME "Chromium Embedded Framework")
set(CEF_FRAMEWORK_LIB "${frameworks_dir}/${CEF_FRAMEWORK_NAME}.framework/${CEF_FRAMEWORK_NAME}")
set(OLD_CEF_PATH "@executable_path/Frameworks/${CEF_FRAMEWORK_NAME}.framework/${CEF_FRAMEWORK_NAME}")
set(NEW_CEF_PATH "@executable_path/../Frameworks/${CEF_FRAMEWORK_NAME}.framework/${CEF_FRAMEWORK_NAME}")

if(EXISTS "${CEF_FRAMEWORK_LIB}")
  message(STATUS "Fixing CEF framework paths...")
  message(STATUS "  Framework: ${CEF_FRAMEWORK_LIB}")
  message(STATUS "  Old path: ${OLD_CEF_PATH}")
  message(STATUS "  New path: ${NEW_CEF_PATH}")

  # Fix framework's install_name
  execute_process(
    COMMAND install_name_tool -id "${NEW_CEF_PATH}" "${CEF_FRAMEWORK_LIB}"
    RESULT_VARIABLE id_result
  )
  message(STATUS "  install_name_tool -id result: ${id_result}")

  # Fix executable's reference to framework
  execute_process(
    COMMAND install_name_tool -change "${OLD_CEF_PATH}" "${NEW_CEF_PATH}" "${macos_dir}/jellyfin-desktop-cef"
    RESULT_VARIABLE change_result
  )
  message(STATUS "  install_name_tool -change result: ${change_result}")

  # Verify the change
  execute_process(
    COMMAND otool -L "${macos_dir}/jellyfin-desktop-cef"
    OUTPUT_VARIABLE verify_output
  )
  message(STATUS "  Executable dependencies after fix:")
  message(STATUS "${verify_output}")
else()
  message(WARNING "CEF framework not found at ${CEF_FRAMEWORK_LIB}")
endif()

#
# resolve_dependency: Resolve @rpath/@loader_path/absolute paths to actual files
#
function(resolve_dependency dep_path out_var)
  set(result "")

  if(dep_path MATCHES "^@rpath/(.+)")
    set(dep_name "${CMAKE_MATCH_1}")
    # Try brew lib first
    if(EXISTS "${brew_lib}/${dep_name}")
      set(result "${brew_lib}/${dep_name}")
    else()
      # Search Cellar for libs not symlinked to main lib dir
      file(GLOB cellar_candidates "${brew_prefix}/Cellar/*/*/lib/${dep_name}")
      if(cellar_candidates)
        list(GET cellar_candidates 0 result)
      endif()
    endif()
  elseif(dep_path MATCHES "^@loader_path/(.+)")
    get_filename_component(dep_name "${CMAKE_MATCH_1}" NAME)
    if(EXISTS "${brew_lib}/${dep_name}")
      set(result "${brew_lib}/${dep_name}")
    else()
      file(GLOB cellar_candidates "${brew_prefix}/Cellar/*/*/lib/${dep_name}")
      if(cellar_candidates)
        list(GET cellar_candidates 0 result)
      endif()
    endif()
  elseif(dep_path MATCHES "^(/opt/homebrew|/usr/local)")
    if(EXISTS "${dep_path}")
      set(result "${dep_path}")
    endif()
  endif()

  set(${out_var} "${result}" PARENT_SCOPE)
endfunction()

#
# fix_lib_dependencies: Fix library paths for a single dylib
#
function(fix_lib_dependencies lib framework_libs_var)
  set(framework_libs ${${framework_libs_var}})

  execute_process(
    COMMAND otool -L "${lib}"
    OUTPUT_VARIABLE otool_output
    ERROR_QUIET
    OUTPUT_STRIP_TRAILING_WHITESPACE
  )

  string(REPLACE "\n" ";" otool_lines "${otool_output}")

  foreach(line ${otool_lines})
    string(STRIP "${line}" line)

    # Check if dependency needs fixing
    set(needs_fix FALSE)
    if(line MATCHES "^(@rpath|@loader_path|/opt/homebrew|/usr/local)")
      set(needs_fix TRUE)
    endif()

    if(NOT needs_fix)
      continue()
    endif()

    # Extract dependency path (remove compatibility version suffix)
    string(REGEX REPLACE " \\(compatibility.*$" "" dep_path "${line}")
    string(STRIP "${dep_path}" dep_path)

    # Resolve to actual file
    resolve_dependency("${dep_path}" resolved_path)
    if(NOT resolved_path)
      message(WARNING "Could not resolve: ${dep_path}")
      continue()
    endif()

    get_filename_component(dep_name "${resolved_path}" NAME)
    set(target "@executable_path/../Frameworks/${dep_name}")

    # Copy if not already in Frameworks
    list(FIND framework_libs "${dep_name}" idx)
    if(idx EQUAL -1 AND EXISTS "${resolved_path}")
      # Resolve symlinks
      get_filename_component(real_path "${resolved_path}" REALPATH)
      message(STATUS "Bundling: ${dep_name}")
      file(COPY "${real_path}" DESTINATION "${frameworks_dir}")
      # Rename if needed
      get_filename_component(real_name "${real_path}" NAME)
      if(NOT "${real_name}" STREQUAL "${dep_name}")
        file(RENAME "${frameworks_dir}/${real_name}" "${frameworks_dir}/${dep_name}")
      endif()
      # Set library id
      execute_process(COMMAND install_name_tool -id "${target}" "${frameworks_dir}/${dep_name}" ERROR_QUIET)
      list(APPEND framework_libs "${dep_name}")
      set(${framework_libs_var} "${framework_libs}" PARENT_SCOPE)
      # Queue for recursive processing
      set_property(GLOBAL APPEND PROPERTY LIBS_TO_FIX "${frameworks_dir}/${dep_name}")
    endif()

    # Fix reference in current lib
    message(STATUS "  Fixing: ${dep_path} -> ${target}")
    execute_process(COMMAND install_name_tool -change "${dep_path}" "${target}" "${lib}" ERROR_QUIET)
  endforeach()
endfunction()

# Build initial list of framework libs
file(GLOB existing_dylibs "${frameworks_dir}/*.dylib")
set(framework_libs "")
foreach(f ${existing_dylibs})
  get_filename_component(fname "${f}" NAME)
  list(APPEND framework_libs "${fname}")
endforeach()

# Collect all libs to fix - start with MacOS dir libs
file(GLOB macos_dylibs "${macos_dir}/*.dylib")
set_property(GLOBAL PROPERTY LIBS_TO_FIX ${macos_dylibs})

# Also add the main executable
set_property(GLOBAL APPEND PROPERTY LIBS_TO_FIX "${macos_dir}/jellyfin-desktop-cef")

# Process libs iteratively (handles newly discovered deps)
set(max_iterations 50)
set(iteration 0)
while(iteration LESS max_iterations)
  get_property(libs_to_fix GLOBAL PROPERTY LIBS_TO_FIX)
  if(NOT libs_to_fix)
    break()
  endif()

  math(EXPR iteration "${iteration} + 1")
  message(STATUS "=== Pass ${iteration} ===")

  # Clear the queue and process
  set_property(GLOBAL PROPERTY LIBS_TO_FIX "")
  list(REMOVE_DUPLICATES libs_to_fix)

  foreach(lib ${libs_to_fix})
    if(EXISTS "${lib}")
      get_filename_component(libname "${lib}" NAME)
      message(STATUS "Processing: ${libname}")
      fix_lib_dependencies("${lib}" framework_libs)
    endif()
  endforeach()
endwhile()

message(STATUS "Library path fixing complete (${iteration} passes)")

# List all bundled libraries
file(GLOB final_dylibs "${frameworks_dir}/*.dylib")
message(STATUS "=== Bundled libraries ===")
foreach(lib ${final_dylibs})
  get_filename_component(libname "${lib}" NAME)
  message(STATUS "  ${libname}")
endforeach()

#
# Code signing (ad-hoc, inside-out order)
#
message(STATUS "Signing app bundle...")

# Sign CEF framework (must sign nested items first, inside-out)
set(entitlements_file "@CMAKE_SOURCE_DIR@/resources/macos/entitlements.plist")
set(cef_framework "${frameworks_dir}/Chromium Embedded Framework.framework")

if(EXISTS "${cef_framework}")
  # Sign nested dylibs in CEF framework's Libraries/ first
  file(GLOB cef_nested_libs "${cef_framework}/Libraries/*.dylib")
  foreach(lib ${cef_nested_libs})
    message(STATUS "  Signing CEF nested: ${lib}")
    execute_process(COMMAND codesign --force --sign - --entitlements "${entitlements_file}" "${lib}")
  endforeach()

  # Sign the main framework binary
  message(STATUS "  Signing CEF framework binary")
  execute_process(COMMAND codesign --force --sign - --entitlements "${entitlements_file}" "${cef_framework}/Chromium Embedded Framework")

  # Sign the framework bundle
  message(STATUS "  Signing CEF framework bundle")
  execute_process(COMMAND codesign --force --sign - --entitlements "${entitlements_file}" "${cef_framework}")
endif()

# Sign other frameworks
file(GLOB framework_dirs "${frameworks_dir}/*.framework")
foreach(fw ${framework_dirs})
  if(NOT "${fw}" STREQUAL "${cef_framework}")
    message(STATUS "  Signing framework: ${fw}")
    execute_process(COMMAND codesign --force --sign - --entitlements "${entitlements_file}" "${fw}")
  endif()
endforeach()

# Sign all dylibs and other executables in Frameworks
file(GLOB framework_dylibs "${frameworks_dir}/*.dylib")
foreach(lib ${framework_dylibs})
  message(STATUS "  Signing: ${lib}")
  execute_process(COMMAND codesign --force --sign - --entitlements "${entitlements_file}" "${lib}")
endforeach()

# Sign standalone binaries in Frameworks (e.g., Python)
file(GLOB framework_files "${frameworks_dir}/*")
foreach(f ${framework_files})
  if(NOT IS_DIRECTORY "${f}" AND NOT "${f}" MATCHES "\\.dylib$")
    # Check if it's a Mach-O binary
    execute_process(
      COMMAND file "${f}"
      OUTPUT_VARIABLE file_type
      OUTPUT_STRIP_TRAILING_WHITESPACE
    )
    if(file_type MATCHES "Mach-O")
      message(STATUS "  Signing binary: ${f}")
      execute_process(COMMAND codesign --force --sign - --entitlements "${entitlements_file}" "${f}")
    endif()
  endif()
endforeach()

# Sign dylibs in MacOS
file(GLOB macos_dylibs "${macos_dir}/*.dylib")
foreach(lib ${macos_dylibs})
  message(STATUS "  Signing: ${lib}")
  execute_process(COMMAND codesign --force --sign - "${lib}" ERROR_QUIET)
endforeach()

# Sign the main executable with entitlements (required for CEF JIT)
message(STATUS "  Signing executable with entitlements")
execute_process(COMMAND codesign --force --sign - --entitlements "${entitlements_file}" "${macos_dir}/jellyfin-desktop-cef" ERROR_QUIET)

# Sign the app bundle last with entitlements
message(STATUS "  Signing app bundle")
execute_process(
  COMMAND codesign --force --sign - --entitlements "${entitlements_file}" "${app}"
  RESULT_VARIABLE sign_result
)
if(NOT sign_result EQUAL 0)
  message(WARNING "Code signing failed")
endif()

# Remove quarantine attribute if present
execute_process(COMMAND xattr -cr "${app}" ERROR_QUIET)

message(STATUS "Bundle complete: ${app}")
