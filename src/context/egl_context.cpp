#include "context/egl_context.h"
#include "logging.h"
#include <cstring>

#ifdef SDL_PLATFORM_LINUX
#include <wayland-egl.h>
#include <X11/Xlib.h>
#endif

EGLContext_::EGLContext_() = default;

EGLContext_::~EGLContext_() {
    cleanup();
}

bool EGLContext_::init(SDL_Window* window) {
    // Detect Wayland vs X11
    const char* videoDriver = SDL_GetCurrentVideoDriver();
    is_wayland_ = videoDriver && strcmp(videoDriver, "wayland") == 0;

    SDL_PropertiesID props = SDL_GetWindowProperties(window);

    if (is_wayland_) {
        // Wayland path
        struct wl_display* wl_display = static_cast<struct wl_display*>(
            SDL_GetPointerProperty(props, SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER, nullptr));
        struct wl_surface* wl_surface = static_cast<struct wl_surface*>(
            SDL_GetPointerProperty(props, SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER, nullptr));

        if (!wl_display || !wl_surface) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to get Wayland display/surface from SDL");
            return false;
        }

        display_ = eglGetPlatformDisplay(EGL_PLATFORM_WAYLAND_KHR, wl_display, nullptr);
        if (display_ == EGL_NO_DISPLAY) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to get EGL display (Wayland)");
            return false;
        }

        // Initialize EGL
        EGLint major, minor;
        if (!eglInitialize(display_, &major, &minor)) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to initialize EGL");
            return false;
        }
        LOG_INFO(LOG_GL, "[EGL] Initialized EGL %d.%d (Wayland)", major, minor);

        // Bind OpenGL ES API
        if (!eglBindAPI(EGL_OPENGL_ES_API)) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to bind OpenGL ES API");
            return false;
        }

        // Choose config
        EGLint config_attribs[] = {
            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
            EGL_RED_SIZE, 8,
            EGL_GREEN_SIZE, 8,
            EGL_BLUE_SIZE, 8,
            EGL_ALPHA_SIZE, 8,
            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT,
            EGL_NONE
        };

        EGLint num_configs;
        if (!eglChooseConfig(display_, config_attribs, &config_, 1, &num_configs) || num_configs == 0) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to choose config");
            return false;
        }

        // Create context
        EGLint context_attribs[] = {
            EGL_CONTEXT_MAJOR_VERSION, 3,
            EGL_CONTEXT_MINOR_VERSION, 0,
            EGL_NONE
        };

        context_ = eglCreateContext(display_, config_, EGL_NO_CONTEXT, context_attribs);
        if (context_ == EGL_NO_CONTEXT) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to create context");
            return false;
        }

        // Get window size in pixels (for HiDPI support)
        SDL_GetWindowSizeInPixels(window, &width_, &height_);

        // Create wayland-egl window and EGL surface at pixel size
        egl_window_ = wl_egl_window_create(wl_surface, width_, height_);
        if (!egl_window_) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to create wayland-egl window");
            return false;
        }

        surface_ = eglCreateWindowSurface(display_, config_, (EGLNativeWindowType)egl_window_, nullptr);
        if (surface_ == EGL_NO_SURFACE) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to create window surface");
            wl_egl_window_destroy(egl_window_);
            egl_window_ = nullptr;
            return false;
        }
    } else {
        // X11 path
        Display* x11_display = static_cast<Display*>(
            SDL_GetPointerProperty(props, SDL_PROP_WINDOW_X11_DISPLAY_POINTER, nullptr));
        Window x11_window = static_cast<Window>(
            SDL_GetNumberProperty(props, SDL_PROP_WINDOW_X11_WINDOW_NUMBER, 0));

        if (!x11_display || !x11_window) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to get X11 display/window from SDL");
            return false;
        }

        display_ = eglGetPlatformDisplay(EGL_PLATFORM_X11_KHR, x11_display, nullptr);
        if (display_ == EGL_NO_DISPLAY) {
            // Fallback to default display
            display_ = eglGetDisplay((EGLNativeDisplayType)x11_display);
        }
        if (display_ == EGL_NO_DISPLAY) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to get EGL display (X11)");
            return false;
        }

        // Initialize EGL
        EGLint major, minor;
        if (!eglInitialize(display_, &major, &minor)) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to initialize EGL");
            return false;
        }
        LOG_INFO(LOG_GL, "[EGL] Initialized EGL %d.%d (X11)", major, minor);

        // Bind OpenGL ES API
        if (!eglBindAPI(EGL_OPENGL_ES_API)) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to bind OpenGL ES API");
            return false;
        }

        // Choose config
        EGLint config_attribs[] = {
            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
            EGL_RED_SIZE, 8,
            EGL_GREEN_SIZE, 8,
            EGL_BLUE_SIZE, 8,
            EGL_ALPHA_SIZE, 8,
            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT,
            EGL_NONE
        };

        EGLint num_configs;
        if (!eglChooseConfig(display_, config_attribs, &config_, 1, &num_configs) || num_configs == 0) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to choose config");
            return false;
        }

        // Create context
        EGLint context_attribs[] = {
            EGL_CONTEXT_MAJOR_VERSION, 3,
            EGL_CONTEXT_MINOR_VERSION, 0,
            EGL_NONE
        };

        context_ = eglCreateContext(display_, config_, EGL_NO_CONTEXT, context_attribs);
        if (context_ == EGL_NO_CONTEXT) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to create context");
            return false;
        }

        // Get window size in pixels (for HiDPI support)
        SDL_GetWindowSizeInPixels(window, &width_, &height_);

        // Create EGL surface directly from X11 window
        surface_ = eglCreateWindowSurface(display_, config_, (EGLNativeWindowType)x11_window, nullptr);
        if (surface_ == EGL_NO_SURFACE) {
            LOG_ERROR(LOG_GL, "[EGL] Failed to create window surface (X11)");
            return false;
        }
    }

    // Make context current
    if (!eglMakeCurrent(display_, surface_, surface_, context_)) {
        LOG_ERROR(LOG_GL, "[EGL] Failed to make context current");
        return false;
    }

    // Enable vsync
    eglSwapInterval(display_, 1);

    LOG_INFO(LOG_GL, "[EGL] Context created successfully");
    LOG_INFO(LOG_GL, "[EGL] GL_VERSION: %s", glGetString(GL_VERSION));
    LOG_INFO(LOG_GL, "[EGL] GL_RENDERER: %s", glGetString(GL_RENDERER));

    return true;
}

void EGLContext_::cleanup() {
    if (display_ != EGL_NO_DISPLAY) {
        eglMakeCurrent(display_, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
        if (context_ != EGL_NO_CONTEXT) {
            eglDestroyContext(display_, context_);
            context_ = EGL_NO_CONTEXT;
        }
        if (surface_ != EGL_NO_SURFACE) {
            eglDestroySurface(display_, surface_);
            surface_ = EGL_NO_SURFACE;
        }
        eglTerminate(display_);
        display_ = EGL_NO_DISPLAY;
    }
    if (egl_window_) {
        wl_egl_window_destroy(egl_window_);
        egl_window_ = nullptr;
    }
}

void EGLContext_::swapBuffers() {
    eglSwapBuffers(display_, surface_);
}

bool EGLContext_::resize(int width, int height) {
    if (width == width_ && height == height_) {
        return true;
    }
    width_ = width;
    height_ = height;
    if (is_wayland_ && egl_window_) {
        wl_egl_window_resize(egl_window_, width, height, 0, 0);
    }
    // X11 window resize is handled by SDL/X11VideoLayer
    return true;
}
